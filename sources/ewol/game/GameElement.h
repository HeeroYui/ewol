/**
 * @author Edouard DUPIN
 * 
 * @copyright 2011, Edouard DUPIN, all right reserved
 * 
 * @license BSD v3 (see license file)
 */

#ifndef __EWOL_GAME_ELEMENT_H__
#define __EWOL_GAME_ELEMENT_H__

#include <etk/Types.h>
#include <ewol/Debug.h>
#include <ewol/oObject/Sprite.h>
#include <ewol/widget/Widget.h>
#include <ewol/game/SceneElement.h>
#include <math.h>

#define CYCLIC_CALL_PERIODE_US     (10000)
#define NB_SPECIAL_PARAM           (5)

namespace ewol {
	
	class GameElement
	{
		private:
			etk::UString m_fileNameConfig;
		protected:
			SceneElement &         m_sceneElement;  //!< All element neede in the scene
			uint16_t               m_uniqueId;      //!< General element ID (uint16_t, because all is reference with the groupId like this only a uint32_t reference an element)
			uint16_t               m_group;         //!< General group Id More than 65000 group can be really interesting to create supid game ...
			float                  m_life;          //!< Current life of the element
			int32_t                m_type;          //!< 
			float                  m_power;         //!< Current power of the element
			bool                   m_visible;       //!< This is to know if the element is displayed or not ==> TODO : check if usefull ...
			vec2                   m_position;      //!< Current position of the element
			float                  m_speed;         //!< Speed of the element (only one value, the angle is generated by the m_angle
			float                  m_angle;         //!< Angle of the speed
			float                  m_mass;          //!< Current element Mass ==> for the physical calculation
			float                  m_size;          //!< Current size of the element more specific size can be done in the under class => this is for simplify calculation ==> all is consider like sphere...
			float                  m_sizeDisplay;   //!< Current diplay size of the element
			bool                   m_canBeCibled;   //!< This is for automatic finding on an ennemy
			bool                   m_canHaveImpact; //!< detection of impact is done with this ...
			float                  m_specialParam[NB_SPECIAL_PARAM]; //!< specific game user parameter
			bool                   m_enable;        //!< Use to add element that can not be detected by the other when user select a place
		public:
			/**
			 * @brief Constructor : here are requested all the needed sprite and effect that can be used in the game
			 * @param ---
			 * @return ---
			 */
			GameElement(SceneElement & sceneElement, etk::UString& tmpName);
			/**
			 * @brief Destructor : This does not remove the sprite requested, they will be supressed when the scene is removed ...
			 * @param ---
			 * @return ---
			 */
			virtual ~GameElement(void) { };
			
			virtual void Init(void) { };
			virtual void UnInit(void) { };
			
			uint16_t    GetUniqueId(void)                         { return m_uniqueId; };
			
			bool             HasName(etk::UString tmpName)        { return (tmpName == m_fileNameConfig); };
			bool             IsVisible(void)                      { return m_visible; };
			void             SetVisible(bool state)               { m_visible = state; StatusUpdate();};
			bool             IsEnable(void)                       { return m_enable; };
			void             SetEnable(bool state)                { m_enable = state; StatusUpdate();};
			vec2  PositionGet(void)                    { return m_position; };
			void             PositionSet(vec2 state)   { m_position = state; StatusUpdate();};
			void             PositionSet(float xxx, float yyy)    { m_position.x = xxx; m_position.y = yyy; StatusUpdate();};
			float    SpeedGet(void)                               { return m_speed; };
			void     SpeedSet(float state)                        { m_speed = state; StatusUpdate();};
			float    MassGet(void)                                { return m_mass; };
			void     MassSet(float state)                         { m_mass = state; StatusUpdate();};
			float    SizeGet(void)                                { return m_size; };
			void     SizeSet(float state)                         { m_size = state; StatusUpdate();};
			float    DisplaySizeGet(void)                         { return m_sizeDisplay; };
			void     DisplaySizeSet(float state)                  { m_sizeDisplay = state; StatusUpdate();};
			float    AngleGet(void)                               { return m_angle; };
			void     AngleSet(float state)
			{
				m_angle = state;
				while (m_angle > M_PI) {
					m_angle -= 2.0*M_PI;
				}
				while (m_angle < -M_PI) {
					m_angle += 2.0*M_PI;
				}
				StatusUpdate();
			};
			float    PowerGet(void)                               { return m_power; };
			void     PowerSet(float state)                        { m_power = state; StatusUpdate();};
			bool     CanBeCibledGet(void)                         { return m_canBeCibled; };
			void     CanBeCibledSet(bool state)                   { m_canBeCibled = state; StatusUpdate();};
			bool     CanHaveImpactGet(void)                       { return m_canHaveImpact; };
			void     CanHaveImpactSet(bool state)                 { m_canHaveImpact = state; StatusUpdate();};
			
			int32_t  GetType(void)                                { return m_type; }; // TODO : DEPRECATED ...
			int32_t  TypeGet(void)                                { return m_type; };
			uint16_t GroupGet(void)                               { return m_group; };
			void     GroupSet(uint16_t state)                     { m_group = state; StatusUpdate();};
			
			float    SpecialParamGet(int32_t id)                  { if (id<0 || id>=NB_SPECIAL_PARAM) {return 0.0;} return m_specialParam[id]; };
			void     SpecialParamSet(int32_t id, float state)     { if (id<0 || id>=NB_SPECIAL_PARAM) {return;} m_specialParam[id]=state; StatusUpdate();};
			
			/**
			 * @brief Periodicly this fuction will be call tu change property of all the dynamic obbjects
			 * @param[in] time Current game time (start at 0)
			 * @param[in] deltaTime delta time before the previous call
			 * @param[in,out] listOfSprite Reference on the list where the display must be done for every sprite
			 * @param[in,out] listOfEffects Reference on the list where the display must be done for every effects
			 * @return true if the object must be remove
			 * @return false if the object must be keep
			 */
			virtual bool Process(int64_t time, int32_t deltaTime) { return false; };
			
			/**
			 * @brief Requuest the draw of the current element, it will be done on the current Sprite list
			 * @param[in,out] listOfSprite Reference on the list where the display must be done for every sprite
			 * @param[in,out] listOfEffects Reference on the list where the display must be done for every effects
			 * @return ---
			 */
			virtual void Draw(void) { };
			/**
			 * @brief an element has been remove, just remove reference on it or ID on IT, it can be replace whith an other that have no link
			 * @param[in] idOfElement Id of the element that has been removed
			 * @return ---
			 */
			virtual void RemoveElement(int32_t idOfElement) { };
			virtual bool HaveImpact(int32_t group, int32_t type, vec2  position, float size);
			virtual bool Explosion(int32_t group, int32_t type, vec2  position, float pxAtenuation, float power) { return false; } ;
			
			virtual etk::UString Message(etk::UString control, etk::UString message) { return ""; } ;
			virtual void StatusUpdate(void) { };
	};
	
};

#include <ewol/widget/Scene.h>

float quadDist(vec2  pos1, vec2  pos2);

#endif
